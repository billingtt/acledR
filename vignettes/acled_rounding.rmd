---
title: "ACLED Rounding"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{ACLED Rounding}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# ACLED Rounding

`acled_rounding()`is a utility function providing a more "intuitive" way of rounding in R, contrary to base R`s "round to even". The concept of rounding to even is something that may be particularly useful for statistics (a discipline closely aligned with the origins of R Language), however, it can be rather unintuative if users want a more routine approach. 

`acledR::acled_rounding()` is a rather straight forward function, closely following the structure of base R's `round()`:

```{r, echo=TRUE, eval=FALSE}
acled_rounding(num, digits = 0)
```

The arguments of `acled_rounding()` are first the number to round up (`num`) , and the number of digits to round towards (`digits`). The when digits equals to 1, it rounds to the tenths place (result = 0.1), 2 rounds to the hundredths place (result = 0.01), and -1 rounds to a tens place (result = 10), -2 rounds to a hundred place (result = 100) and so on. More intutively, each value means the number of digits next to the `.`. 


# Example - Rounding in acledR and in Base R

To put it simply, the formula performs a simple task - round like we round in day-to-day interactions. That is, 

-   If 2.5 -> 3
-   If 2.4 -> 2
-   If 2.7 -> 3

The example below highlights such a difference (note that the difference only appears when rounding a number where the target digit is equal to 5):

```{r, echo = TRUE}
library(acledR)

x1 <- 9.5
x2 <- 8.5
x3 <- 1.45

# First lets see how base R does it:
round(x1)
round(x2)
round(x3, digits = 0)
round(x3, digits = 1)
```

In the example above we can see that base R is rather inconsistent rounding. `x1` is round to 10, so it is rounded up. But `x2` is rounded down to 8, even if the last digit is the same in both cases - 5. This is the main issues that `acled_rounding()` aims to solve: base R rounds on the result's whole number. It is not that `round()` is not consistent - it is, it consistently rounds to even.

Lets now explore how `acled_rounding()` approaches the task:

```{r}
acled_rounding(x1)
acled_rounding(x2)
acled_rounding(x3, digits = 0)
acled_rounding(x3, digits = 1)
```

As we can see, acledR's function deviates from base R by rounding up when the last digit is 5. The differences can be noted in x2 and x3, both of these rounding up when the last digit was 5. 
