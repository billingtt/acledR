---
title: "Accessing and Utilizing ACLED's API"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Accessing and Utilizing ACLED's API}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  warning = F, 
  message = F,
  cache = F
)
```

## Access to the API

In order to use the ACLED API, you must first register an account at [ACLED's Access Portal](developer.acleddata.com). You can then pass your account information to `R` to use the `acled_api()` function. This information includes the email and access key associated with your ACLED account. 

Once you have acquired your credentials (email and key), you can either use `acled_access()` to verify that the credentials are correct (note that this counts as one download against your quota) and store these in the environment for a given session, or manually store them in the environment file to use them permanently across every session.

To use `acled_access()` (recommended), run the following:

```{r, eval = F}
acled_access("your_email", "your_key") # to be run every session before doing an API call. 
```

Alternatively, to manually store them as an environmental variable, run:

```{r, eval = F}
file.edit(file.path("~", ".Renviron"))
```

which will open your `.Renviron` file. Once there, set:

```{r, eval = F}
Sys.setenv(email_address = "your_email")
Sys.setenv(acled_key = "your_key")
```

and save the file. If you run `Sys.getenv("email_address")`, your associated email will print; if you run `Sys.getenv("acled_key")`, your ACLED key will print to the console.

## Acled API

`acled_api()` is a wrapper to request and process ACLED API calls. The function takes the following parameters:

```{r, eval = F}
acled_api(email = NULL,
          key = NULL,
          countries = NULL,
          regions = NULL,
          start_date = "1997-01-01",
          end_date = Sys.Date(),
          timestamp = NULL,
          event_types = NULL,
          monadic = FALSE,
          ...,
          acled_access = TRUE,#acled_access=TRUE only works when acled_access() was run beforehand, eliminating the need of email-key in acled_api()
          prompt = TRUE)

```

## Parameters for the API

The `countries` and `regions` parameters specify where in the world to pull data from. If both are NULL (the default), the API will return data for all countries available. Specific countries may be requested via a vector of country names. Similarly, entire regions may be requested via a vector of region names or numeric codes. `acledR::acled_countries` and `acledR::acled_regions` shows the full lists of countries and regions available. If you specify both countries and regions, the call will return only cases that fit both arguments. For example, if you request `countries = c("Nigeria", "Mexico")` and `regions = c("Western Africa")`, only Nigeria will be returned since Mexico is not in Western Africa.

The `start_date` and `end_date` parameters specify the time period requested in "yyyy-mm-dd" format. 

With `timestamp` users can keep their data sets updated, as it allows them to indicate a time stamp from when to collect events. `timestamp` is not the same `event_date`, as time stamp indicates when the event was added/modified in ACLED's data set. To learn more about how to keep your data sets up to date, please visit this [guide](https://acleddata.com/acleddatanew/wp-content/uploads/dlm_uploads/2019/07/ACLED_Timestamp-Memo_Methodology-Note_6.2019.pdf).

Users can also use `event_types` to specify an event type that they would be interested on. For this, users are required to enter the event type of interest as a string. For example `event_types = "battles"`.

`monadic` is a logical parameter, which is `FALSE` by default and returns the dyadic version of the data . If set to `TRUE`, the monadic version based on actor 1 and actor 2 will be returned.

The `...` parameter stands for other arguments that one would like to include for the final query, such as ISO or interaction. To utilize other arguments not included in the function parameters, write them as "&paramenter=value", so for example: "&iso=4" (NOTE: there is no space in between characters). To learn more about other valid parameters please visit our [API guide](https://acleddata.com/acleddatanew//wp-content/uploads/dlm_uploads/2021/11/API-User-Guide_Feb2022.pdf).

The `acled_access` parameter is used to let the function know that you have used `acled_access` during the current session, thus, avoiding the need to include email and key on the function. If `acled_access` is set to `FALSE`, then the email and key arguments are necessary.

Finally, the `prompt` argument corresponds to how the function handles big calls, and whether the user is interested on receiving the interactive prompt which includes, among other information, if their API call will be split in more than 1 call, and if the user wants to do so. In cases where the users may not want to have this interactive prompt, such as users utilizing this function as part of a routine script, users can set `prompt = FALSE` to run the function without the need of the interactive prompt. 

## Handling big API calls

As it is common across APIs, handling big data requires particular tweaks. In our case, the base API offers the possibility of utilizing pagination to address some of these issues, a process that can be confusing for newer users working with APIs, and making very big pulls of data is often unreliable - which is why we recommend to do smaller calls. However, in this package we provide a solution to both of these issues.

First, in terms of pagination, our wrapper does this for the user automatically, so there is no need to include pagination in their calls. 

Second, in terms of big calls, the `acled_api()` function will first evaluate approximately how much data is the user requesting, and after this, the user will be prompted with a message which includes: number of countries requested, number of country-days, number of API calls needed, and a question whether the user would like to proceed. Currently, `acled_api()` works with a threshold of 300,000 country-days to determine whether to split the function. This way users can be rest assured that the call will not hit any issues because of it being too large (a problem some users encountered before), but also, users now have more control over the calls they make in relation to the API quota. 

If users prefer to skip the interactive prompt, they can do so by using the argument `prompt = FALSE`. While this ignores the interactive prompt, the call will still be split if it reaches the threshold.


## Example

To see how this works in practice, we will show an example gathering events from Brazil from January 2022 to the present.

```{r}
library(acledR)
library(dplyr)

acled_access(email = "acledexamples@gmail.com", key = "M3PWwg3DIdhHMuDiilp5") #  This is an example, you will need to input your credentials.

df_br <- acled_api(countries = c("Brazil"),
                   start_date = "2022-01-01",
                   end_date = Sys.Date(),
                   monadic = F,
                   acled_access = TRUE,
                   prompt = F)
```

The results return a tibble with each ACLED event in Brazil during this time period:

```{r}
df_br %>% 
  glimpse()
```

If instead we wanted multiple countries, we could execute:

```{r}
df_br_co <- acled_api(countries = c("Brazil", "Colombia"),
                      start_date = "2022-01-01",
                      end_date = Sys.Date(),
                      monadic = F,
                      acled_access = TRUE,
                      prompt = F)
```

For an entire region, we omit the `countries` parameter and supply a `regions` argument. Additionally, for only gathering protests we provide an event_type argument:

```{r}
df_sa <- acled_api(regions = c("South America"),
                   start_date = "2022-01-01",
                   end_date = Sys.Date(),
                   event_type = "Protests",
                   monadic = F,
                   acled_access = TRUE,
                   prompt = F)
```

To include time stamps from when to download the data, we add it as either a string ("yyyy-mm-dd") or as a numeric Unix time stamp:

```{r}
df_br_co <- acled_api(countries = c("Brazil", "Colombia"),
                      start_date = "2022-01-01",
                      end_date = Sys.Date(),
                      monadic = F,
                      # timestamp = "2022-01-24" -> in the case of string
                      timestamp = 1643056974, # -> in the case of a numeric Unix timestamp
                      acled_access = TRUE,
                      prompt = F)
```

If we would like to include only one type of interaction, in this case "Rioters versus Civilians" = 57, we add the interaction code to the `extra` argument:

```{r}
df_sa <- acled_api(countries = c("Brazil", "Colombia"),
                   start_date = "2022-01-01",
                   end_date = "2022-04-30",
                   monadic = F,
                   ... = "&interaction=57",
                   acled_access = TRUE,
                   prompt = F)
```

We could also request the monadic version of the data based on actor 1 and actor 2 by setting `monadic = TRUE`:

```{r}
df_sa_monadic <- acled_api(regions = c("South America"),
                           start_date = "2022-01-01",
                           end_date = Sys.Date(),
                           monadic = T,
                           acled_access = TRUE,
                           prompt = F)
```

In both the dyadic and monadic versions, the API returns `r length(unique(df_sa$event_id_cnty))` unique events. However, the number of unique entries for the dyadic version is also `r length(df_sa$event_id_cnty)`, while it's `r length(df_sa_monadic$event_id_cnty)` for the monadic version.
