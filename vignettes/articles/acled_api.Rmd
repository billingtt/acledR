---
title: "Accessing and Utilizing ACLED's API"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Accessing and Utilizing ACLED's API}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  warning = F, 
  message = F,
  cache = F
)
```

## Accessing the API

To use ACLED's [API](https://acled.github.io/ACLED-api-guide/), you must first register an account in [ACLED's Access Portal](developer.acleddata.com). You can get more information about registering your account by visiting ACLED’s [access guide](https://acleddata.com/download/35300/). Your account will provide credentials (your email and a unique key). You can use these credentials in R by either:

-   (recommended) Using `acled_access()` to verify the credentials (this counts as one download in your quota), then by storing your credentials in your local environment for a given session 

-   Manually storing them in the environment file to use them permanently across all sessions.

To use `acled_access()`, you can run the following:

```{r, eval = F}
acled_access("your_email", "your_key") # to be run every session before doing an API call. 
```

Alternatively, to manually store your credentials as an environmental variable you can run:

```{r, eval = F}
file.edit(file.path("~", ".Renviron"))
```

which will open your `.Renviron` file. Once there you can set:

```{r, eval = F}
email_address = "your_email"
acled_key = "your_key"
```

and save the file.

After inputting your credentials, you can confirm that they have been properly stored by running `Sys.getenv("email_address")` to return the stored email address, and `Sys.getenv("acled_key")` to return the stored ACLED key in the console.

## ACLED API

`acled_api()` is a wrapper to request and process ACLED API calls. The function takes the following parameters:

```{r, eval = F}
acled_api(email = NULL,
          key = NULL,
          countries = NULL,
          regions = NULL,
          start_date = "1997-01-01",
          end_date = Sys.Date(),
          timestamp = NULL,
          event_types = NULL,
          monadic = FALSE,
          ...,
          acled_access = TRUE, 
          prompt = TRUE)

```

## Parameters for the API

### Geographical filters

The `countries` and `regions` parameters specify where to pull data. If both are `NULL`, or are not included, the API will return data for all countries available. Specific countries may be requested via a vector of country names (e.g., `c("Argentina","Spain","Bolivia")`).

Similarly, entire regions may be requested via a vector of region names or numeric codes. `acledR::acled_countries` and `acledR::acled_regions` show the full lists of countries and regions available; otherwise, you can visit the [Geography vignette](`r vignette("Geography")`).

If you specify both countries and regions, the call will return only cases where both are compatible. For example: If you request `countries = c("Nigeria", "Mexico")` and `regions = c("Western Africa")`, you will receive only data from Nigeria since Mexico is not in Western Africa.

### Temporal filters

The `start_date` and `end_date` parameters specify the date range in the "yyyy-mm-dd" format.

With `timestamp` you can keep your datasets updated, indicating a Unix timestamp from when to collect events. `timestamp` is not the same as `event_date`, as `timestamp` stands for when the event was added/modified in ACLED's dataset. To learn more about how to keep your datasets up to date, please visit this [guide](https://acleddata.com/download/35179/).

You can also use `event_types` to filter by *event_types*. For this, you must enter the *event_type* of interest as a string (e.g., `event_types = "Battles"` or `event_types = c("Battles", "Protests")`).

### Additional filters

`monadic` is a logical parameter, which is `FALSE` by default and returns the dyadic version of the data. When `monadic=TRUE`, a monadic ("long-form") data frame with only one actor (based on *actor1* and *actor2*) will be returned. For transforming your dataset from wide to long without utilizing the API, visit `r vignette("Transformation of ACLED data")`.

The `...` parameter stands for any other arguments one would like to include for the final query, such as *ISO* or *Interaction*. To utilize different filters not included in the parameters above, write them as `&paramenter=value`, such as `&iso=4`. To learn more about other valid parameters, please visit our [API guide](https://acled.github.io/ACLED-api-guide/acled_endpoint.html).

### Function options

The `acled_access` parameter allows you to exclude email and key on the function when `acled_access()` has been used beforehand or the credentials are stored as environment variables. If `acled_access` is set to `FALSE`, then the email and key arguments are necessary.

The `prompt` argument corresponds to how the function handles big calls. This option refers to whether you are interested in receiving an interactive prompt about the required API calls. If you do not want this interactive prompt (e.g, because `acled_api()` is part of a routine script), you can set `prompt = FALSE` to run the function without the prompt.



## Handling big API calls

As common across APIs, handling big chunks of data requires tweaks. In our case, the base API utilizes pagination to address some of these issues. This can be confusing for newer users working with APIs. Luckily for you, this package allows you to bypass these issues.

Instead of pagination, our wrapper splits the call automatically, so there is no need to include pagination in your calls.

Additionally, the `acled_api()` function will first estimate how much data you are requesting. Based on this, you will be prompted with a message which includes the following:

-   The number of countries requested,

-   The number of `country-days` requested,

-   The number of API calls needed,

-   A question about whether you would like to proceed.[a][b]

Currently, `acled_api()` works with a threshold of 300,000 `country-days` to determine whether to split the function. `country-days` are a measure utilized by `acledR` to estimate the amount of data requested by the user. To be more specific, `country-days` is an estimation based on an approximation of how many country-days are in the full dataset. To be more precise, `N country-day = N countries * N days`. We use the results of the formula to break down the API call to avoid any timeout issues. In brief, it approximates the amount of data per country requested, based on how many days of data are requested per country. 

**Note:** `country-data` is only used for the internal workings of the function, so as to optimize the API call - it is not an analytical measurement, or a representation of how many data is available per country**. 
Thanks to this, under most circumstances, you will avoid running into issues related to the size of the call. Additionally, you can have more control over your API quota as you can see the number of calls required.

If you prefer to skip the interactive prompt, set the argument to `prompt = FALSE`. While this ignores the interactive prompt, the call will still be split if it reaches the threshold.

## Example

Let's review an example to see how this works in practice.

Imagine you are gathering events from Brazil from January 2022 to December 2022.

```{r}
library(acledR)
library(dplyr)

# This is an example, you will need to input your credentials.
acled_access(email = "acledexamples@gmail.com", key = "M3PWwg3DIdhHMuDiilp5") 

df_br <- acled_api(countries = c("Brazil"),
                   start_date = "2022-01-01",
                   end_date = "2022-12-01",
                   monadic = F,
                   acled_access = TRUE,
                   prompt = F)
```

This returns a tibble with each ACLED event in Brazil during this period:

```{r}
df_br %>% 
  glimpse()
```

If you want multiple countries, you would execute the following:

```{r}
df_br_co <- acled_api(countries = c("Brazil", "Colombia"),
                      start_date = "2022-01-01",
                      end_date = "2022-12-01",
                      monadic = F,
                      acled_access = TRUE,
                      prompt = F)
```

For an entire region, you can omit the `countries` parameter and supply a `regions` argument instead. Additionally, for only getting “Protests”, you can provide an `event_type` argument:

```{r}
df_sa <- acled_api(regions = c("South America"),
                   start_date = "2022-01-01",
                   end_date = "2022-12-01",
                   event_type = "Protests",
                   monadic = F,
                   acled_access = TRUE,
                   prompt = F)
```

To utilize the *timestamp* column/filter to download the data, you can add it as either a string ("yyyy-mm-dd") or as a numeric Unix timestamp:

```{r}
df_br_co <- acled_api(countries = c("Brazil", "Colombia"),
                      start_date = "2022-01-01",
                      end_date = "2022-12-01",
                      monadic = F,
                      # timestamp = "2022-01-24" -> in the case of string
                      timestamp = 1643056974, # -> in the case of a numeric Unix timestamp
                      acled_access = TRUE,
                      prompt = F)
```

If you would like to include only one type of *Interaction*, in this case, "Rioters versus Civilians (57)", You should add the *Interaction* code to the `...` argument:

```{r}
df_sa <- acled_api(countries = c("Brazil", "Colombia"),
                   start_date = "2022-01-01",
                   end_date = "2022-12-01",
                   monadic = F,
                   ... = "&interaction=57",
                   acled_access = TRUE,
                   prompt = F)
```

You could also request the monadic version of the data by setting `monadic = TRUE`:

```{r}
df_sa_monadic <- acled_api(regions = c("South America"),
                           start_date = "2022-01-01",
                           end_date = "2022-12-01",
                           monadic = T,
                           acled_access = TRUE,
                           prompt = F)
```

In both the dyadic and monadic versions, the API returns `r length(unique(df_sa$event_id_cnty))` unique events. However, the number of unique entries for the dyadic version is also `r length(df_sa$event_id_cnty)`, while it's `r length(df_sa_monadic$event_id_cnty)` for the monadic version.

Best of luck!

[a]This section is a bit redundant with the `prompt` bit a couple paragraphs up. Mayb work the prompt section into here?
[b]Mm i think i disagree here. The paragraphs above explain the option to enable the prompt, without providing much info about the prompt itself. (That is intentionally because first I introduce the components of the function) 

Whereas here we go more in depth into what the prompt is. Although I do agree, I need to nail the country-days definition.
