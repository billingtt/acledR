---
title: "Accessing and Utilizing ACLED's API"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Accessing and Utilizing ACLED's API}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  warning = F, 
  message = F,
  cache = F
)
```

## Access to the API

To use ACLED's [API](https://acled.github.io/ACLED-api-guide/), you must first register an account at [ACLED's Access Portal](developer.acleddata.com), visit our [access guide](https://acleddata.com/download/35300/) for more information. Once you acquire your credentials (email and key), you can either:

-   (recommended) Use `acled_access()` to verify the credentials (counts one download in your quota) and store these in the environment for a given session.

-   Manually store them in the environment file to use them permanently across sessions.

To use `acled_access()`, run the following:

```{r, eval = F}
acled_access("your_email", "your_key") # to be run every session before doing an API call. 
```

Alternatively, to manually store them as an environmental variable, run:

```{r, eval = F}
file.edit(file.path("~", ".Renviron"))
```

which will open your `.Renviron` file. Once there, set:

```{r, eval = F}
Sys.setenv(email_address = "your_email")
Sys.setenv(acled_key = "your_key")
```

and save the file.

Either way, to verify that you have stored your credentials properly, you can run `Sys.getenv("email_address")`, and the email you registered with should print; if you run `Sys.getenv("acled_key")`, your ACLED key will print to the console.

## ACLED API

`acled_api()` is a wrapper to request and process ACLED API calls. The function takes the following parameters:

```{r, eval = F}
acled_api(email = NULL,
          key = NULL,
          countries = NULL,
          regions = NULL,
          start_date = "1997-01-01",
          end_date = Sys.Date(),
          timestamp = NULL,
          event_types = NULL,
          monadic = FALSE,
          ...,
          acled_access = TRUE, 
          prompt = TRUE,
          log = F)

```

## Parameters for the API

### Geographical filters

The `countries` and `regions` parameters specify where to pull data. If both are `NULL`, or are not included, the API will return data for all countries available. Specific countries may be requested via a vector of country names (e.g., `c("Argentina","Spain","Bolivia")`).

Similarly, entire regions may be requested via a vector of region names or numeric codes. `acledR::acled_countries` and `acledR::acled_regions` show the full lists of countries and regions available; otherwise, you can visit the [Geography vignette](`r vignette("Geography")`).

If you specify both countries and regions, the call will return only cases where both are compatible. For example: If you request `countries = c("Nigeria", "Mexico")` and `regions = c("Western Africa")`, you will receive only data from Nigeria since Mexico is not in Western Africa.

### Temporal filters

The `start_date` and `end_date` parameters specify the date range in the "yyyy-mm-dd" format.

With `timestamp` you can keep your datasets updated, indicating a Unix timestamp from when to collect events. `timestamp` is not the same as `event_date`, as `timestamp` stands for when the event was added/modified in ACLED's dataset. To learn more about how to keep your datasets up to date, please visit this [guide](https://acleddata.com/download/35179/).

You can also use `event_types` to filter by *event_types*. For this, you must enter the *event_type* of interest as a string (e.g., `event_types = "Battles"` or `event_types = c("Battles", "Protests")`).

### Additional filters

`monadic` is a logical parameter, which is `FALSE` by default and returns the dyadic version of the data. When `monadic=TRUE`, a monadic ("long-form") data frame with only one actor (based on *actor1* and *actor2*) will be returned. For transforming your dataset from wide to long without utilizing the API, visit `r vignette("Transformation of ACLED data")`.

The `...` parameter stands for any other arguments one would like to include for the final query, such as *ISO* or *Interaction*. To utilize different filters not included in the parameters above, write them as `&paramenter=value`, such as `&iso=4`. To learn more about other valid parameters, please visit our [API guide](https://acled.github.io/ACLED-api-guide/acled_endpoint.html).

### Function options

The `acled_access` parameter allows you to exclude email and key on the function when `acled_access()` has been used beforehand or the credentials are stored as environment variables. If `acled_access` is set to `FALSE`, then the email and key arguments are necessary.

The `prompt` argument corresponds to how the function handles big calls. This option refers to whether you are interested in receiving an interactive prompt about the required API calls. If you do not want this interactive prompt (e.g, because `acled_api()` is part of a routine script), you can set `prompt = FALSE` to run the function without the prompt.

Finally, the `log` option provides an alternative to executing the normal API call. Instead, it provides a data frame with the countries requested, the date range requested, and the country-days unit. We recommend this option only for testing; otherwise, it provides little to no analytical value.

## Handling big API calls

As common across APIs, handling big chunks of data requires tweaks. In our case, the base API utilizes pagination to address some of these issues. This can be confusing for newer users working with APIs. Luckily for you, this package allows you to bypass these issues.

Instead of pagination, our wrapper splits the call automatically, so there is no need to include pagination in your calls.

Additionally, the `acled_api()` function will first estimate how much data you are requesting. Based on this, you will be prompted with a message which includes the following:

-   The number of countries requested,

-   The number of `country-days` requested,

-   The number of API calls needed,

-   A question about whether you would like to proceed.

Currently, `acled_api()` works with a threshold of 300,000 `country-days` to determine whether to split the function. Thus, under most circumstances, you will avoid running into issues related to the size of the call. Additionally, you can have more control over your API quota as you can see the number of calls required.

If you prefer to skip the interactive prompt, set the argument to `prompt = FALSE`. While this ignores the interactive prompt, the call will still be split if it reaches the threshold.

## Example

Let's review an example to see how this works in practice.

Imagine you are gathering events from Brazil from January 2022 to December 2022.

```{r}
library(acledR)
library(dplyr)

# This is an example, you will need to input your credentials.
acled_access(email = "acledexamples@gmail.com", key = "M3PWwg3DIdhHMuDiilp5") 

df_br <- acled_api(countries = c("Brazil"),
                   start_date = "2022-01-01",
                   end_date = "2022-12-01",
                   monadic = F,
                   acled_access = TRUE,
                   prompt = F)
```

This returns a tibble with each ACLED event in Brazil during this period:

```{r}
df_br %>% 
  glimpse()
```

If you want multiple countries, you could execute the following:

```{r}
df_br_co <- acled_api(countries = c("Brazil", "Colombia"),
                      start_date = "2022-01-01",
                      end_date = "2022-12-01",
                      monadic = F,
                      acled_access = TRUE,
                      prompt = F)
```

For an entire region, you can omit the `countries` parameter and supply a `regions` argument instead. Additionally, for only getting “Protests”, you can provide an `event_type` argument:

```{r}
df_sa <- acled_api(regions = c("South America"),
                   start_date = "2022-01-01",
                   end_date = "2022-12-01",
                   event_type = "Protests",
                   monadic = F,
                   acled_access = TRUE,
                   prompt = F)
```

To utilize the *timestamp* column/filter to download the data, you can add it as either a string ("yyyy-mm-dd") or as a numeric Unix timestamp:

```{r}
df_br_co <- acled_api(countries = c("Brazil", "Colombia"),
                      start_date = "2022-01-01",
                      end_date = "2022-12-01",
                      monadic = F,
                      # timestamp = "2022-01-24" -> in the case of string
                      timestamp = 1643056974, # -> in the case of a numeric Unix timestamp
                      acled_access = TRUE,
                      prompt = F)
```

If you would like to include only one type of *Interaction*, in this case, "Rioters versus Civilians (57)", You should add the *Interaction* code to the `...` argument:

```{r}
df_sa <- acled_api(countries = c("Brazil", "Colombia"),
                   start_date = "2022-01-01",
                   end_date = "2022-12-01",
                   monadic = F,
                   ... = "&interaction=57",
                   acled_access = TRUE,
                   prompt = F)
```

You could also request the monadic version of the data by setting `monadic = TRUE`:

```{r}
df_sa_monadic <- acled_api(regions = c("South America"),
                           start_date = "2022-01-01",
                           end_date = "2022-12-01",
                           monadic = T,
                           acled_access = TRUE,
                           prompt = F)
```

In both the dyadic and monadic versions, the API returns `r length(unique(df_sa$event_id_cnty))` unique events. However, the number of unique entries for the dyadic version is also `r length(df_sa$event_id_cnty)`, while it's `r length(df_sa_monadic$event_id_cnty)` for the monadic version.
