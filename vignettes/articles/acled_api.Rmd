---
title: "Accessing and Utilizing ACLED's API"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Accessing and Utilizing ACLED's API}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  warning = F, 
  message = F,
  cache = F
)
```

## Accessing the API

To use ACLED's [API](https://acled.github.io/ACLED-api-guide/), you must first register an account in [ACLED's Access Portal](developer.acleddata.com). You can find more information about registering your account by visiting ACLED’s [access guide](https://acleddata.com/download/35300/). Your account will provide credentials (your email and a unique key) which you can use in R by either:

-   (recommended) Using `acled_access()` to verify your credentials then by storing your credentials in your local environment for a given session.

-   Manually storing your credentials for permanent use across all sessions.

You can store your credentials using  `acled_access()` by using the following:

```{r, eval = F}
acled_access("your_email", "your_key") # to be run every session before doing an API call. 
```

Alternatively, to manually store your credentials as a variable in the R environment you can run:

```{r, eval = F}
file.edit(file.path("~", ".Renviron"))
```

which will open your `.Renviron` file. Once there you can set:

```{r, eval = F}
email_address = "your_email"
acled_key = "your_key"
```

Afterwards you should save the file.

After inputting your credentials, you can confirm that they have been properly stored by running `Sys.getenv("email_address")` to return the stored email address, and `Sys.getenv("acled_key")` to return the stored ACLED key in the console.

## ACLED API

`acled_api()` is a wrapper you can use to request and process ACLED API calls. The function takes the following parameters:

```{r, eval = F}
acled_api(email = NULL,
          key = NULL,
          countries = NULL,
          regions = NULL,
          start_date = "1997-01-01",
          end_date = Sys.Date(),
          timestamp = NULL,
          event_types = NULL,
          monadic = FALSE,
          ...,
          acled_access = TRUE, 
          prompt = TRUE)

```

## Parameters for the API

### Geographical filters

You can use the `countries` and `regions` parameters to specify the locations from which you would like to request data. If both values are `NULL` or are not included, the API will return data for all countries and regions. If you would like to request data for multiple countries, you can do so by using a vector of country names (e.g., `c("Argentina","Spain","Bolivia")`). Similarly, you can request data from one or more region by using either a vector of region names or numeric codes. `acledR::acled_countries` and `acledR::acled_regions` show the full lists of countries and regions available. You can also visit ACLED’s [Geography vignette](`r vignette("Geography")`) for more information.

Please note that if you include values for both countries and regions, the function will only return cases that match both criteria. For example, if you request `countries = c("Nigeria", "Mexico")` and `regions = c("Western Africa")`, you will only receive data from Nigeria since Mexico is not in Western Africa.

### Temporal filters

You can specify the date range for which you would like to receive data by using the `start_date` and `end_date` parameters, both of which are in "yyyy-mm-dd" format.

You can use the `timestamp` parameter to select data that were added or amended over a specific time period. Please keep in mind that `timestamp` indicates when the event was added or modified in ACLED’s dataset, meaning that an event that occurred far in the past (i.e. with an old `event_date`) may still have a new Unix timestamp if it was recently amended. In practice, the `timestamp` parameter is typically used to keep your own dataset up to date as changes are made to ACLED data. To learn more about how to keep your datasets up to date, please visit this [guide](https://acleddata.com/download/35179/).

You can also use `event_types` to filter by *event_types*. For this, you must enter the *event_type* of interest as a string (e.g., `event_types = "Battles"` or `event_types = c("Battles", "Protests")`).

### Additional filters

`monadic` is a logical parameter, which is `FALSE` by default and returns the dyadic version of the data. When `monadic=TRUE`, a monadic ("long-form") data frame with only one actor (based on *actor1* and *actor2*) will be returned. For transforming your dataset from wide to long without utilizing the API, visit `r vignette("Transformation of ACLED data")`.

The `...` parameter represents any other arguments you might like to include in your API query, such as *ISO* or *Interaction*. If you want to use these filters or other not included in the list of parameters described above, then you can write them as `&paramenter=value`. For instance, you might wish to include `&iso=4` at the end of the function. You can visit ACLED’s [API guide](https://acled.github.io/ACLED-api-guide/acled_endpoint.html) to learn more about other valid parameters.

### Function options

You can exclude email and key on the function when `acled_access()` has been used beforehand or the credentials are stored as environment variables. Alternatively, you can set `acled_access` to `FALSE` then manually include your email and key as arguments in the function..

You can use the `prompt` argument to specify how the function handles API calls that return large amounts of data. If `prompt=TRUE` then you will receive an interactive prompt (see `Handling big API calls` immediately below). If you do not want this interactive prompt (e.g, because `acled_api()` is part of a routine script), then you can set `prompt = FALSE`.



## Handling big API calls

As is common when executing API calls, handling large volumes of data requires some special consideration. In ACLED’s case, the base API uses pagination to address some of these issues, but pagination can be confusing for newer users (see our [API guide](https://acled.github.io/ACLED-api-guide/) for a more detailed explanation). Fortunately, this package avoids the issue. Instead of pagination, the `acled_api()` wrapper splits the call automatically.

Instead, when `prompt=TRUE` or by default the `acled_api()` function will first estimate how much data you are requesting. You will then be prompted with a message which includes the following:

-   The number of countries for which data are requested,

-   The number of `country-days` for which data are requested, where `country-days` are the number of days in the specified date range multiplied by the number of countries for which data are requested,

-   The number of API calls needed based on an estimate where 300,000 `country-days` are assumed to fit in one API call without experiencing timeout issues,

-   A question asking whether, given this information and your limited number of available API calls, you would like to proceed with your API call.[a][b]

**Note:** `country-day` is only used to estimate the amount of data requested–it is not an analytical measurement and does not represent the amount of data available for each country. 

## Example

Imagine you are interested in events from Brazil spanning from January 1st 2022 to December 1st 2022.

```{r}
library(acledR)
library(dplyr)

#**Note:** This is simply an example–you will need to include your own credentials rather than the email and key placeholders that are included below.

acled_access(email = "acledexamples@gmail.com", key = "M3PWwg3DIdhHMuDiilp5") 

df_br <- acled_api(countries = c("Brazil"),
                   start_date = "2022-01-01",
                   end_date = "2022-12-01",
                   monadic = F,
                   acled_access = TRUE,
                   prompt = F)
```

This returns a tibble with each ACLED event in Brazil during the specified period:

```{r}
df_br %>% 
  glimpse()
```

If you want data from both Brazil and Colombia, you would execute the following:

```{r}
df_br_co <- acled_api(countries = c("Brazil", "Colombia"),
                      start_date = "2022-01-01",
                      end_date = "2022-12-01",
                      monadic = F,
                      acled_access = TRUE,
                      prompt = F)
```

If you are interested in events occurring over a larger area, it may be simpler to omit the `countries` parameter and include a `regions` argument instead. You could also include an `event_type` argument to receive only a specific type of event:

```{r}
df_sa <- acled_api(regions = c("South America"),
                   start_date = "2022-01-01",
                   end_date = "2022-12-01",
                   event_type = "Protests",
                   monadic = F,
                   acled_access = TRUE,
                   prompt = F)
```

You can use the *timestamp* column/filter to specify the dates from which you would like to receive new or amended data. You can include the argument as either a string ("yyyy-mm-dd") or a numeric Unix timestamp:

```{r}
df_br_co <- acled_api(countries = c("Brazil", "Colombia"),
                      start_date = "2022-01-01",
                      end_date = "2022-12-01",
                      monadic = F,
                      # timestamp = "2022-01-24" -> in the case of string
                      timestamp = 1643056974, # -> in the case of a numeric Unix timestamp
                      acled_access = TRUE,
                      prompt = F)
```

If you would like to include only one type of *interaction* (e.g. "Rioters versus Civilians (57)"), then you can add *interaction* code to the `...` argument:

```{r}
df_sa <- acled_api(countries = c("Brazil", "Colombia"),
                   start_date = "2022-01-01",
                   end_date = "2022-12-01",
                   monadic = F,
                   ... = "&interaction=57",
                   acled_access = TRUE,
                   prompt = F)
```

You could also request the monadic version of the data by setting `monadic = TRUE`:

```{r}
df_sa_monadic <- acled_api(regions = c("South America"),
                           start_date = "2022-01-01",
                           end_date = "2022-12-01",
                           monadic = T,
                           acled_access = TRUE,
                           prompt = F)
```

In both the dyadic and monadic versions, the API returns `r length(unique(df_sa$event_id_cnty))` unique events. However, the number of unique entries for the dyadic version is also `r length(df_sa$event_id_cnty)`, while it's `r length(df_sa_monadic$event_id_cnty)` for the monadic version.

Best of luck!
