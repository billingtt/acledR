---
title: "Transformation of ACLED data"
output: html_document
date: "2022-11-11"
vignette: >
  %\VignetteIndexEntry{Transformation of ACLED data}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---
```{r loading packs, echo = F, message=FALSE}
library(kableExtra)
library(knitr)
library(acledR)
library(dplyr)
```

The ACLED dataset is designed with user readability in mind. At times, this focus might conflict with standard clean data principles, such as having only a single value per column and row. To facilitate a more programmatic handling of our dataset, we've introduced the data manipulation suite of functions in the `acledR` package. This suite of functions enable you to reformat the data structure to adhere more closely to tidy data conventions.

## 1. Filter functions - `acled_filter_actor()`

ACLED data is typically in a wide format, meaning that it can be somewhat more difficult to filter to specific values because those values may be spread across multiple columns. For instance, it may take multiple lines of code to filter to all events involving a particular actor, because that actor could be included in several different columns (i.e. *actor1*, *actor 2*, *assoc_actor_1* and *assoc_actor_2*).

To make filtering across multiple columns easier, `acledR` includes the function `acled_filter_actor()`.

```{r, eval = FALSE}

acled_filter_actors(df,
                                      actors, 
                                      filter_cols=‘all’)

```

The function is relatively straightforward and includes only three arguments:

-   `df`: a dataset that corresponds to ACLED’s column structure, 
-   `actors`: a character vector of the actors to which you are interested in filtering,
-   `filter_cols`: a character vector of the columns used for filtering.

For `filter_cols`, you can utilize a vector with the names of the different actor columns, such as `filter_cols = c(“actor1”,”actor2”)`'. If you leave this argument blank, the default is to filter by all actor columns in the dataframe. 

**Note:** that if you use the option `filter_cols = ‘all'`, the `df` you provide must follow the structure of ACLED’s data and thus include *assoc_actor_1* or *assoc_actor_2* columns.

## 2. From wide to long - `acled_transform()`

The other data manipulation function is `acled_transform()` which will allow you to switch between wide and long formats without the need to make a new API call. Typical ACLED data is in a wide format, with multiple actors represented in each row, and those actors interacting during an event (see our [API interactive guide](https://acled.github.io/ACLED-api-guide/acled_endpoint.html#dyadic-versus-monadic-formats---export_type) for a more detailed explanation). However, you may wish to conduct actor-based analyses that are better suited to a long data format where each actor has a separate row, and a single event may therefore be represented in multiple rows. 

```{r setup, eval = FALSE}

acled_transform(data, 
                type = "full_actors") 

```

`acled_transform()` requires two arguments: 

*   `data`: The dataset to transform (must follow ACLED's structure[a]) 

*   `type`: A character vector indicating which columns to transpose (the columns that go from wide to long format). 

The available column options upon which ACLED data can be transposed, as indicated in the `type` argument are: 

1.  `full_actor`: Transposes all the actor columns in the dataset (*actor1*, *actor2*, *assoc_actor_1*, *assoc_actor_2*). There will be a separate row for each actor or associate actor involved in each event.

2.  `main_actors`: Transposes only *actor1* and *actor2*. There will be separate rows for main actors only. 

3.  `assoc_actors`: Transposes only *assoc_actor_1* and *assoc_actor_2* columns. There will be separate rows for associate actors only. 

4.  `source`: Transposes only the *source* column. There will be a separate row for each source in the source column.

Keep in mind that you can receive some of these data formats directly from ACLED’s API, but that using this function can provide some added benefits: 

-   You can use this function to transform a dyadic dataset to a monadic dataset, thus receiving the latter without executing an additional API call. 

-   You have more control over the columns used to go from wide to long format. This function allows you to transpose on the following columns: *actor1 & actor2*, *assoc_actor_1*, *assoc_actor_2*, and *source*. The API only allows you to receive long-format data based on *actor1* & *actor2*.

## Example

In this section we will walkthrough a potential use case for the transformation functions to explain how users can take advantage of these. 

For this example, assume that you want data of South America throughout the first half of 2023. 

```{r}
library(acledR)

acled_access(email = "acledexamples@gmail.com", key = "M3PWwg3DIdhHMuDiilp5") 

df_sa <- acled_api(regions = "South America",
                   start_date = "2023-01-01",
                   end_date = "2023-06-01",
                   monadic = F,
                   acled_access = TRUE,
                   prompt = F)
```

Now, filter to spot events of the "Military Forces of Colombia (2022-)". 

```{r}

mil_colombia <- acled_filter_actors(df_sa,"Military Forces of Colombia (2022-)", filter_cols = "all")

```

In the filter events there are 143 rows, meaning 143 events where the "Military Forces of Colombia (2022-)" participated. However, if you take a look more closely, the actor of interest is not only in the main columns (i.e, "COL20021"). 

Assume now that you want to count how many events does each actor participates in. The problem is that for doing that, you would need to sum all the times the actor appears in the four columns. That, while possible, is unnecessarily complicated when you can transform your dataset into long form, where each actor is spread across rows rather than columns. For that, you can use `acled_transform()`:

```{r}

df_sa_long <- acled_transform(df_sa, type = "full_actors")

```

The dataset is now into long form, so you are left with groupping by actor, and counting by **unique** *event_id_cnty*. It is very important to count by unique ids, because when transforming data to long, we duplicate events, creating rows per event equivalent to the number of actors involved. 

```{r}
library(tidyr)
library(dplyr)

actors_df_sa <- df_sa_long %>%
  group_by(actor) %>%
  summarise(n_events = n_distinct(unique(event_id_cnty)))

```

To verify your results, filter the actor counts to only "Military Forces of Colombia (2022-)". 

```{r}

actors_df_sa %>%
  filter(actor == "Military Forces of Colombia (2022-)") %>%
  .$n_events
```
The number of events matches the number of rows you got after using `acled_filter_actors()`, meaning that you effectively captured the number of events by each actor. 

This highlights the advantage of both `acled_filter_actors` and `acled_transform`, which allows you to easily manipulate ACLED column structure to better fit programmatical approaches of analysis. 




[a]@m.start@acleddata.com: I think we need to clarify what this means. Does it mean it needs ALL the columns from the full acled dataset? If so we should probably mention that in the API guide (in the choosing columns section). 

Lucas: I would have assumed that by writing like this, it means that it needs ALL. 



Tho, not sure about the API guide part. Because if you are using the package, I doubt you will use the API, and vice versa.
