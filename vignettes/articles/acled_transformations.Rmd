---
title: "Transformation of ACLED data"
output: html_document
date: "2022-11-11"
vignette: >
  %\VignetteIndexEntry{Transformation of ACLED data}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---

```{r loading packs, echo = F, message=FALSE}
library(kableExtra)
library(knitr)
library(acledR)
library(dplyr)
```

## 1. Filter functions

ACLED's data utilizes a wide format. While this is an easier format for humans to read, it is not the same case for computers.

For that matter, sometimes it can take a couple of lines of code to properly filter data in ACLED's dataset when we are trying to get variables inside wide-formatted columns such as *actor1*, *actor 2*, *assoc_actor_1*,*assoc_actor_2*, and *source*.

Because of that, `acledR` includes two particular functions to easily filter the data across all of these columns while retaining the same structure.

### 1.1. `acled_filter_actor()`.

Operating across actor columns is a prime example of the extra steps users must do to circumvent the column's wide format. Actors are found across four columns, requiring multiple filters or conditions, making filtering slightly tedious.

Thus, the package includes the `acled_filter_actor()` function, which filters the data to the desired actors. The function is structured as follows:

```{r, eval = FALSE}

acled_filter_actors(df,
		    	          actors, 
			              filter_cols=‘all’)

```

The function is relatively straightforward, taking three arguments:

-   `df`: the dataset of interest,
-   `actors`: a character vector of the actors that you are interested in filtering by,
-   `filter_cols`: a character vector of the columns where to check for the actor(s) to filter.

For `filter_cols`, you can utilize a vector with the names of the different actor columns, like `filter_cols = c(“actor1”,”actor2”)`', or we can leave it blank, which defaults in filtering in all columns.

**Note:** that if we utilize the option `filter_cols = ‘all'`, the `df` you provide must follow ACLED's structure, and thus it must have an *assoc_actor_1* or *assoc_actor_2* column.

### 1.2 `acled_filter_event_types()`.

As users may find in ACLED's [methodology guides](https://acleddata.com/download/2827/), we have defined clusters of event types that tend to describe specific categories of political violence or disorder. These are:

```{r table_of_categories, echo=FALSE}
acledR::acled_event_categories %>%
  mutate(political_violence = cell_spec(political_violence, "html", background = ifelse(as.numeric(political_violence) > 0, "blue", "white"), color = ifelse(as.numeric(political_violence) > 0, "blue", "white")),
         organized_political_violence = cell_spec(organized_political_violence, "html", color = ifelse(as.numeric(organized_political_violence) > 0, "blue", "white"), background = ifelse(as.numeric(organized_political_violence) > 0, "blue", "white")),
         disorder = cell_spec(disorder, "html", background = ifelse(as.numeric(disorder) > 0, "blue", "white"), color = ifelse(as.numeric(disorder) > 0, "blue", "white")),
         demonstrations = cell_spec(demonstrations, "html", background = ifelse(as.numeric(demonstrations) > 0, "blue", "white"), color = ifelse(as.numeric(demonstrations) > 0, "blue", "white")))%>%
  select(-event_type) %>%
  kable(format = "html", escape = F) %>%
  kable_styling(fixed_thead = T) %>%
  column_spec(2:5,color="white")%>%
  pack_rows(group_label = "Battles", start_row = 1,end_row = 3) %>%
  pack_rows(group_label = "Explosions/Remote violence",start_row=4,end_row = 9) %>%
  pack_rows(group_label = "Protests",start_row = 10, end_row = 12) %>%
  pack_rows(group_label = "Riots", start_row = 13, end_row = 14) %>%
  pack_rows(group_label = "Strategic developments", start_row = 15, end_row = 22) %>%
  pack_rows(group_label = "Violence against civilians", start_row = 23, end_row = 25)
```

The table helps to illustrate the conditional statements that lead to these categories; while also hinting at how time-consuming it may be to filter these categories manually. For that, the package includes the `acled_filter_event_types()` function:

```{r fet function, eval = FALSE}
acled_filter_event_types(data,
                  acled_categories,
                  keep_all_events = FALSE)
```

`acled_filter_event_types()` requires three arguments:

-   `data`: ACLED data frame, like `acled_api()`'s output.

-   `acled_categories`: a character vector of the categories by which we will filter.

-   `keep_all_events`: a logical statement to specify if we want to filter out events. When indicating `keep_all_events = FALSE`, the function returns only the events within the requested categories. On the contrary, if it is `TRUE`, the returned data frame will include new binary columns to indicate if the given event was part of the specified category.

## 2. `acled_transform()`

The last function in our family of data manipulation functions is `acled_transform()`. `acled_transform()` was created to aid you in switching from a wide format to a long form, if required, without the need to make a new API call with the monadic option.

```{r setup, eval = FALSE}

acled_transform(data, 
                type = "full_actors") 

```

`acled_transform()` requires two arguments: \* `data`: The dataset to transform (has to follow ACLED's structure) \* `type`: A character vector indicating which columns to transpose. See below the available categories.

These are the available options to transpose the ACLED data, which we indicate through the `type` argument:

1.  `full_actor`: Transposes all the actor columns in the dataset (*actor1*, *actor2*, *assoc_actor_1*, *assoc_actor_2*).

2.  `main_actors`: Transposes only *actor1* and *actor2*.

3.  `assoc_actors`: Transposes only *assoc_actor_1* and *assoc_actor_2* columns.

4.  `source`: Transposes only the *source* column.

5.  `all`: Transposes all of the aforementioned columns (*actor1*, *actor2*, *assoc_actor_1*, *assoc_actor_2*, *source*).

While the ACLED API includes an option to provide a monadic file, this function offers some extra benefits relative to the API's approach:

-   Users can "save" API calls by providing an already-gathered dyadic dataset, whereas the API monadic options require two distinct calls for a monadic and a dyadic dataset.

-   Users can pivot the dataset to their desired option. ACLED's dataset includes several columns that users may be interested in transposing: *actor1 & actor2*, *assoc_actor_1*, *assoc_actor_2*, and *source*. The API only pivots the *actor1* & *actor2* columns into one *actor1* column, and the *assoc_actor_1* & *assoc_actor_2* columns into one *assoc_actor_1* column.

## acledR Example

Assume that you are trying to do a network analysis of actor interactions in events of Argentina across 2022; more specifically, you want to start analyzing the interactions of the "Mapuche Indigenous Militia (Argentina)".

First, you should collect ACLED data and filter it to events featuring the "Mapuche Indigenous Militia (Argentina)", `acled_filter_actors()` can help you with that.

```{r, eval=TRUE}
library(acledR)
library(dplyr)
library(igraph)

# Provide your credentials
acled_access(email = "acledexamples@gmail.com", key = "M3PWwg3DIdhHMuDiilp5") #  This is an example, you will need to input your credentials.

# Request the Argentinian dataset for 2022
argen_acled <- acled_api(countries = "Argentina",
                         year = 2022, 
                         acled_access = TRUE,
                         prompt = FALSE, 
                         log = F)

# Filter to include only the interactions of your desired actor
mapu_argen <- acled_filter_actors(argen_acled, "Mapuche Indigenous Militia (Argentina)")
```

A crucial step for every network analysis is creating edges and node lists. Given the structure of ACLED's dyadic dataset, there are two columns to consider: *actor1* and *actor2*.

You need to transform the dataset towards a long form, where each *actor1* and *actor2* are in a new row in a single column. For that, you can use `acled_transform()`:

```{r, eval=TRUE}
mapu_actors <- acled_transform(mapu_argen,type = "main_actors")
  
head(mapu_actors)
```

Now you can start creating the node list by collecting all the unique actors in the dataset.

```{r, eval=TRUE}
mapu_node_list <- mapu_actors %>%
  distinct(actor)

print(mapu_node_list)
```

Building the edge list (who interacted with whom) is easy with ACLED data. Our data includes *actor1* and *actor2* columns to identify the main actors in an event, so you need to subset our data frame to have these two columns. You can keep some other data as it adds context to the interactions.

```{r}
mapu_edges <- mapu_argen %>%
  select(actor1,actor2,event_id_cnty,fatalities,event_type,sub_event_type)
```

Now that you have your nodes and edges lists, create a simple network graph of actor interactions. The one thing that is key to remember is that ACLED stores actors in *actor1* and *actor2* regardless of who initiated the event. Thus, interactions in ACLED data are always undirected.

```{r}
# Create the igraph object
mapu_undirected <- igraph::graph_from_data_frame(
  mapu_edges, 
  vertices = mapu_node_list, 
  directed = FALSE
)

# Separate the ego network of the Mapuche Militia
mapu_ego <- make_ego_graph(mapu_undirected, order=1, c("Mapuche Indigenous Militia (Argentina)"))

set.seed(69)
plot(mapu_ego[[1]], layout=layout.fruchterman.reingold, 
     main="Ego network of the Mapuche Indigenous Militia (Argentina)",
     vertex.label.dist=-3)

```

As you can see, through 2022, the "Mapuche Indigenous Militia (Argentina)" interacted mostly with the "Civilians (Argentina)" and also with the police forces of the country of both the Mauricio Macri 2015-2019 government and Alberto Fernandez (current) governments.

This is a basic example of how to start exploring actor interactions with the ACLED dataset and how to use the transformation functions to shape the dataset structure to fit your methodological requirements.
